#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  (ql:quickload '(:getcmd :clails) :silent t)
  )


(defpackage :ros.script.clails.3961085205
  (:use :cl))
(in-package :ros.script.clails.3961085205)

;; Help functions
(defun help ()
  (format t "clails - Common Lisp web application framework~%~%")
  (format t "Usage: clails COMMAND [OPTIONS] [ARGS...]~%~%")
  (format t "Commands:~%")
  (format t "  new <name>                        Create a new project~%")
  (format t "  generate:model <name>             Generate model files~%")
  (format t "  generate:migration <name>         Generate migration file~%")
  (format t "  generate:view <name>              Generate view files~%")
  (format t "  generate:controller <name>        Generate controller file~%")
  (format t "  generate:scaffold <name>          Generate scaffold~%")
  (format t "  generate:task <name>              Generate task file~%")
  (format t "  db:create                         Create database~%")
  (format t "  db:migrate                        Run migrations~%")
  (format t "  db:migrate:up <version>           Migrate up to version~%")
  (format t "  db:migrate:down <version>         Migrate down to version~%")
  (format t "  db:rollback                       Rollback migrations~%")
  (format t "  db:status                         Show migration status~%")
  (format t "  task [TASK] [OPTIONS]             Execute custom tasks~%")
  (format t "  test [packages...]                Run tests~%")
  (format t "  server                            Start web server~%")
  (format t "  stop                              Stop web server~%")
  (format t "~%")
  (format t "Run 'clails COMMAND --help' for more information on a command.~%"))

(defun help/new ()
  (format t "Usage: clails new PROJECT-NAME [OPTIONS]~%~%")
  (format t "Create a new clails project.~%~%")
  (format t "Options:~%")
  (format t "  -p, --path PATH           Project directory path (default: current directory)~%")
  (format t "  -d, --database TYPE       Database type: sqlite3, mysql, postgresql (default: sqlite3)~%")
  (format t "  -h, --help                Show this help message~%")
  (format t "~%")
  (format t "Examples:~%")
  (format t "  clails new myapp~%")
  (format t "  clails new myapp --path /projects~%")
  (format t "  clails new myapp --database mysql~%"))

(defun help/generate ()
  (format t "Usage: clails generate:TYPE NAME [OPTIONS]~%~%")
  (format t "Generate files for model, migration, view, controller, scaffold, or task.~%~%")
  (format t "Commands:~%")
  (format t "  generate:model <name>             Generate model file~%")
  (format t "  generate:migration <name>         Generate migration file~%")
  (format t "  generate:view <name>              Generate view file~%")
  (format t "  generate:controller <name>        Generate controller file~%")
  (format t "  generate:scaffold <name>          Generate model, view, and controller~%")
  (format t "  generate:task <name>              Generate task file~%")
  (format t "~%")
  (format t "Options:~%")
  (format t "  --no-overwrite            Do not overwrite existing files (not available for migration)~%")
  (format t "  -n, --no-migration        Skip migration file generation (model only)~%")
  (format t "  -ns, --namespace NS       Specify namespace for task (task only)~%")
  (format t "  -h, --help                Show this help message~%~%")
  (format t "Examples:~%")
  (format t "  clails generate:task cleanup~%")
  (format t "  clails generate:task import --namespace data~%")
  (format t "  clails generate:task cleanup -ns maintenance~%"))

(defun help/db ()
  (format t "Usage: clails db:COMMAND [OPTIONS]~%~%")
  (format t "Database management commands.~%~%")
  (format t "Commands:~%")
  (format t "  db:create                 Create database~%")
  (format t "  db:migrate                Run all pending migrations~%")
  (format t "  db:migrate --version VER  Run migrations up to specific version~%")
  (format t "  db:migrate:up <version>   Run specific migration up~%")
  (format t "  db:migrate:down <version> Rollback specific migration~%")
  (format t "  db:rollback               Rollback 1 migration (default)~%")
  (format t "  db:rollback --step N      Rollback N migrations~%")
  (format t "  db:seed                   Seed the database~%")
  (format t "  db:status                 Show migration status~%")
  (format t "~%")
  (format t "Options:~%")
  (format t "  --version VERSION         Migration version (for db:migrate)~%")
  (format t "  --step N                  Number of steps to rollback (for db:rollback)~%")
  (format t "  -h, --help                Show this help message~%")
  (format t "~%")
  (format t "Examples:~%")
  (format t "  clails db:create~%")
  (format t "  clails db:migrate~%")
  (format t "  clails db:migrate --version 20231105120000~%")
  (format t "  clails db:migrate:up 20231105120000~%")
  (format t "  clails db:rollback~%")
  (format t "  clails db:rollback --step 3~%"))

(defun help/test ()
  (format t "Usage: clails test [PACKAGES...] [OPTIONS]~%~%")
  (format t "Run tests with optional filtering.~%~%")
  (format t "Arguments:~%")
  (format t "  PACKAGES...               Package names to test (exact match)~%")
  (format t "~%")
  (format t "Options:~%")
  (format t "  --tag TAG                 Include tests with TAG (can be specified multiple times)~%")
  (format t "  --exclude TAG             Exclude tests with TAG (can be specified multiple times)~%")
  (format t "  --list-tags               List all available tags~%")
  (format t "  --list-packages           List all available packages~%")
  (format t "  --list-tests-tag TAG      List tests with specific tag~%")
  (format t "  --list-tests-pkg PKG      List tests in specific package~%")
  (format t "  -h, --help                Show this help message~%")
  (format t "~%")
  (format t "Examples:~%")
  (format t "  clails test                                 Run all tests~%")
  (format t "  clails test pkg1 pkg2                       Run tests in pkg1 and pkg2~%")
  (format t "  clails test --tag model                     Run tests with :model tag~%")
  (format t "  clails test --tag model --tag sqlite3       Run tests with multiple tags~%")
  (format t "  clails test --exclude slow                  Exclude slow tests~%")
  (format t "  clails test --list-tags                     List all available tags~%")
  (format t "  clails test todoapp/models/user             Test specific package~%"))

(defun help/server ()
  (format t "Usage: clails server [OPTIONS]~%~%")
  (format t "Start the web server.~%~%")
  (format t "Options:~%")
  (format t "  -p, --port PORT           Port number (default: 5000)~%")
  (format t "  -b, --bind ADDRESS        Bind address (default: 127.0.0.1)~%")
  (format t "  -s, --swank               Start swank server (default: 127.0.0.1:4005)~%")
  (format t "  --swank-address ADDRES    Specify swank server bind address (default: 127.0.0.1)~%")
  (format t "  --swank-port PORT         Specify swank server port (default: 4005)~%")
  (format t "  -h, --help                Show this help message~%")
  (format t "~%")
  (format t "Examples:~%")
  (format t "  clails server~%")
  (format t "  clails server --port 8080~%")
  (format t "  clails server --bind 0.0.0.0 --port 3000~%")
  (format t "  clails server --swank                                            # Start swank on 127.0.0.1:4005~%")
  (format t "  clails server --swank --swank-address 0.0.0.0 --swank-port 4006  # Start swank on 0.0.0.0:4006~%"))

(defun help/stop ()
  (format t "Usage: clails stop [OPTIONS]~%~%")
  (format t "Stop the running web server.~%~%")
  (format t "Options:~%")
  (format t "  -h, --help                Show this help message~%")
  (format t "~%")
  (format t "Examples:~%")
  (format t "  clails stop~%"))

(defun help/task ()
  (format t "Usage: clails task [TASK] [OPTIONS]~%~%")
  (format t "Execute custom tasks or built-in task system.~%~%")
  (format t "Options:~%")
  (format t "  -l, --list [NAMESPACE]    List all available tasks (optionally filter by namespace)~%")
  (format t "  --info <task>             Show detailed information about a task~%")
  (format t "  -h, --help                Show this help message~%~%")
  (format t "Examples:~%")
  (format t "  clails task --list                        # List all tasks~%")
  (format t "  clails task --list db                     # List tasks in 'db' namespace~%")
  (format t "  clails task --info maintenance:cleanup    # Show info about db:migrate task~%")
  (format t "  clails task maintenance:cleanup           # Run custom task~%"))

;; Utility functions
(defun load-project ()
  (let* ((clails-home (uiop:getenv "CLAILS_HOME"))
         (project-dir (if clails-home
                          (uiop:ensure-directory-pathname clails-home)
                          (uiop/os:getcwd)))
         (boot-file (merge-pathnames "clails.boot" project-dir)))
    (push project-dir ql:*local-project-directories*)
    (load boot-file)))

(defun load-db-package ()
  (let* ((clails-home (uiop:getenv "CLAILS_HOME"))
          (project-dir (if clails-home
                           (uiop:ensure-directory-pathname clails-home)
                           (uiop/os:getcwd)))
          (db-package-file (merge-pathnames "db/package.lisp" project-dir)))
    (load db-package-file)))

;; Command definition macro
(defmacro define-command (name params &body body)
  (let* ((sanitized (substitute #\_ #\: name))
         (fname (intern (string-upcase (format nil "CMD__~A" sanitized)) *package*))
         (help-fname (intern (string-upcase (format nil "HELP__~A" sanitized)) *package*))
         (required-params '())
         (keyword-specs '())
         (options '())
         (state 'required)
         (help-function nil)
         (arguments-as-list nil))
    ;; Check if first element of body is a help function declaration
    (when (and (consp (first body))
               (eq (car (first body)) :help-function))
      (setf help-function (second (first body)))
      (setf body (rest body)))

    (dolist (p params)
      (cond
        ((eq p '&key)
         (setf state 'key))
        ((eq state 'required)
         (push p required-params))
        ((eq state 'key)
         (destructuring-bind (var &rest meta) p
           (let* ((default-pos (position :default meta))
                  (default (and default-pos (nth (1+ default-pos) meta)))
                  (short-pos (position :short-option meta))
                  (short-opt (and short-pos (nth (1+ short-pos) meta)))
                  (long-pos (position :long-option meta))
                  (long-opt (and long-pos (nth (1+ long-pos) meta)))
                  (consume-pos (position :consume meta))
                  (consume (and consume-pos (nth (1+ consume-pos) meta)))
                  (multiple-pos (position :multiple meta))
                  (multiple (and multiple-pos (nth (1+ multiple-pos) meta)))
                  (conv-pos (position :converter meta))
                  (converter (and conv-pos (nth (1+ conv-pos) meta)))
                  (lambda-param (if default `(,var ,default) var))
                  (option-plist `(:keyword ,(intern (string-upcase (symbol-name var)) :keyword)
                                  ,@(when short-opt `(:short-option ,short-opt))
                                  ,@(when long-opt `(:long-option ,long-opt))
                                  ,@(when consume `(:consume ,consume))
                                  ,@(when multiple `(:multiple ,multiple))
                                  ,@(when converter `(:converter ,converter)))))
             (push lambda-param keyword-specs)
             (push option-plist options))))))
    (setf required-params (nreverse required-params))
    (setf keyword-specs (nreverse keyword-specs))
    (setf options (nreverse options))

    ;; Check if first required param looks like a list (e.g., args, files, etc.)
    ;; or if there's exactly one required param - enable arguments-as-list
    (when (and (= (length required-params) 1)
               (not (null required-params)))
      (setf arguments-as-list t))

    `(progn
       (defun ,fname (,@required-params
                      ,@(when keyword-specs `(&key ,@keyword-specs)))
         ,@body)
       ,@(when help-function
           `((defun ,help-fname ()
               (funcall ,help-function))))
       (setf (getf *config* :commands)
             (append (getf *config* :commands)
                     (list (list :command ,name
                                 :function (function ,fname)
                                 ,@(when help-function
                                     `(:help-function (function ,help-fname)))
                                 ,@(when arguments-as-list
                                     `(:arguments-as-list t))
                                 ,@(when options
                                     `(:options (list ,@(mapcar (lambda (opt) `(list ,@opt)) options)))))))))))


(defparameter *config* '(:commands ()))

;; Command definitions
(define-command "new" (args &key (project-path :short-option "p"
                                                :long-option "path"
                                                :consume t)
                                 (database :default :sqlite3
                                           :short-option "d"
                                           :long-option "database"
                                           :consume t
                                           :converter #'(lambda (s) (intern (string-upcase s) :keyword)))
                                 (help :short-option "h"
                                       :long-option "help"))
  (:help-function #'help/new)
  (when help
    (help/new)
    (uiop:quit 0))
  (let ((project-name (first args)))
    (when (null project-name)
      (format *error-output* "ERROR: PROJECT-NAME parameter is required for new command~%")
      (uiop:quit 1))
    (clails/cmd:create-project project-name :project-path project-path :database database)))

(define-command "environment" (&key (help :short-option "h"
                                          :long-option "help"))
  (when help
    (format t "Usage: clails environment~%~%")
    (format t "Show current environment.~%")
    (uiop:quit 0))
  (load-project)
  (format t "environment:~A~%" clails/environment:*project-environment*))

(define-command "db:create" (&key (help :short-option "h"
                                        :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (load-project)
  (clails/cmd:db/create))

(define-command "db:migrate" (&key (version :long-option "version"
                                            :consume t)
                                   (help :short-option "h"
                                         :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (load-project)
  (load-db-package)
  (if version
      (clails/cmd:db/migrate :version version)
      (clails/cmd:db/migrate)))

(define-command "db:migrate:up" (args &key (help :short-option "h"
                                                 :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (let ((version (first args)))
    (when (null version)
      (format *error-output* "ERROR: VERSION parameter is required for db:migrate:up~%")
      (uiop:quit 1))
    (load-project)
    (load-db-package)
    (clails/cmd:db/migrate-up version)))

(define-command "db:migrate:down" (args &key (help :short-option "h"
                                                   :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (let ((version (first args)))
    (when (null version)
      (format *error-output* "ERROR: VERSION parameter is required for db:migrate:down~%")
      (uiop:quit 1))
    (load-project)
    (load-db-package)
    (clails/cmd:db/migrate-down version)))

(define-command "db:rollback" (&key (step :long-option "step"
                                          :consume t)
                                    (help :short-option "h"
                                          :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (load-project)
  (load-db-package)
  (if step
      (clails/cmd:db/rollback :step (parse-integer step))
      (clails/cmd:db/rollback)))

(define-command "db:seed" (&key (help :short-option "h"
                                      :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (load-project)
  (load-db-package)
  (clails/cmd:db/seed))

(define-command "db:status" (&key (help :short-option "h"
                                        :long-option "help"))
  (:help-function #'help/db)
  (when help
    (help/db)
    (uiop:quit 0))
  (load-project)
  (load-db-package)
  (clails/cmd:db/status))

(define-command "generate:model" (args &key (no-overwrite :long-option "no-overwrite")
                                            (no-migration :short-option "n"
                                                          :long-option "no-migration")
                                            (help :short-option "h"
                                                  :long-option "help"))
  (:help-function #'help/generate)
  (when help
    (help/generate)
    (uiop:quit 0))
  (let ((model-name (first args)))
    (when (null model-name)
      (format *error-output* "ERROR: NAME parameter is required for generate:model~%")
      (uiop:quit 1))
    (load-project)
    (clails/cmd:generate/model model-name :no-overwrite no-overwrite :no-migration no-migration)))

(define-command "generate:migration" (args &key (help :short-option "h"
                                                      :long-option "help"))
  (:help-function #'help/generate)
  (when help
    (help/generate)
    (uiop:quit 0))
  (let ((migration-name (first args)))
    (when (null migration-name)
      (format *error-output* "ERROR: NAME parameter is required for generate:migration~%")
      (uiop:quit 1))
    (load-project)
    (clails/cmd:generate/migration migration-name)))

(define-command "generate:view" (args &key (no-overwrite :long-option "no-overwrite")
                                           (help :short-option "h"
                                                 :long-option "help"))
  (:help-function #'help/generate)
  (when help
    (help/generate)
    (uiop:quit 0))
  (let ((view-name (first args)))
    (when (null view-name)
      (format *error-output* "ERROR: NAME parameter is required for generate:view~%")
      (uiop:quit 1))
    (load-project)
    (clails/cmd:generate/view view-name :no-overwrite no-overwrite)))

(define-command "generate:controller" (args &key (no-overwrite :long-option "no-overwrite")
                                                 (help :short-option "h"
                                                       :long-option "help"))
  (:help-function #'help/generate)
  (when help
    (help/generate)
    (uiop:quit 0))
  (let ((controller-name (first args)))
    (when (null controller-name)
      (format *error-output* "ERROR: NAME parameter is required for generate:controller~%")
      (uiop:quit 1))
    (load-project)
    (clails/cmd:generate/controller controller-name :no-overwrite no-overwrite)))

(define-command "generate:scaffold" (args &key (no-overwrite :long-option "no-overwrite")
                                               (help :short-option "h"
                                                     :long-option "help"))
  (:help-function #'help/generate)
  (when help
    (help/generate)
    (uiop:quit 0))
  (let ((name (first args)))
    (when (null name)
      (format *error-output* "ERROR: NAME parameter is required for generate:scaffold~%")
      (uiop:quit 1))
    (load-project)
    (clails/cmd:generate/scaffold name :no-overwrite no-overwrite)))

(define-command "generate:task" (args &key (namespace :short-option "ns"
                                                      :long-option "namespace"
                                                      :consume t)
                                           (help :short-option "h"
                                                 :long-option "help"))
  (:help-function #'help/generate)
  (when help
    (help/generate)
    (uiop:quit 0))
  (let ((name (first args)))
    (when (null name)
      (format *error-output* "ERROR: NAME parameter is required for generate:task~%")
      (uiop:quit 1))
    (load-project)
    (clails/cmd:generate/task name :namespace namespace)))

(define-command "test" (args &key (tags :long-option "tag"
                                        :consume t
                                        :multiple t)
                                  (exclude :long-option "exclude"
                                           :consume t
                                           :multiple t)
                                  (list-tags :long-option "list-tags")
                                  (list-packages :long-option "list-packages")
                                  (list-tests-tag :long-option "list-tests-tag"
                                                  :consume t)
                                  (list-tests-pkg :long-option "list-tests-pkg"
                                                  :consume t)
                                  (help :short-option "h"
                                        :long-option "help"))
  (:help-function #'help/test)
  (when help
    (help/test)
    (uiop:quit 0))

  (load-project)

  ;; Set environment to test after loading project
  (clails/environment:set-environment "test")

  ;; Convert args (list of package names) to uppercase
  (let* ((package-names (mapcar #'string-upcase args))
         ;; Helper function to convert string to keyword
         (string-to-keyword (lambda (s)
                              (if (stringp s)
                                  (if (and (> (length s) 0) (char= (char s 0) #\:))
                                      (intern (subseq s 1) :keyword)
                                      (intern (string-upcase s) :keyword))
                                  s)))
         (ensure-keyword-list (lambda (val)
                                (when val
                                  (let ((lst (if (listp val) val (list val))))
                                    (mapcar string-to-keyword lst)))))
         (tags-keywords (funcall ensure-keyword-list tags))
         (exclude-keywords (funcall ensure-keyword-list exclude))
         (list-tests-tag-kw (when list-tests-tag
                              (funcall string-to-keyword list-tests-tag)))
         (list-tests-pkg-upper (when list-tests-pkg
                                 (string-upcase list-tests-pkg))))

    (let ((test-result
           (clails/cmd:test :packages package-names
                            :tags tags-keywords
                            :exclude-tags exclude-keywords
                            :list-tags list-tags
                            :list-packages list-packages
                            :list-tests-tag list-tests-tag-kw
                            :list-tests-pkg list-tests-pkg-upper)))
      (if test-result
          (uiop:quit 0)
          (uiop:quit 1)))))

(define-command "server" (&key (port :default "5000"
                                     :short-option "p"
                                     :long-option "port"
                                     :consume t)
                               (bind :default "127.0.0.1"
                                     :short-option "b"
                                     :long-option "bind"
                                     :consume t)
                               (swank :short-option "s"
                                      :long-option "swank")
                               (swank-address :default "127.0.0.1"
                                              :long-option "swank-address"
                                              :consume t)
                               (swank-port :long-option "swank-port"
                                           :consume t)
                               (help :short-option "h"
                                     :long-option "help"))
  (:help-function #'help/server)
  (when help
    (help/server)
    (uiop:quit 0))
  (load-project)
  (clails/cmd:server :port port
                     :bind bind
                     :swank-port (cond
                                   (swank-port swank-port)
                                   (swank "4005")
                                   (t nil))
                     :swank-address swank-address))

(define-command "stop" (&key (help :short-option "h"
                                   :long-option "help"))
  (:help-function #'help/stop)
  (when help
    (help/stop)
    (uiop:quit 0))
  (load-project)
  (clails/cmd:stop))

(define-command "task" (args &key (list :short-option "l"
                                        :long-option "list")
                                  (info :long-option "info"
                                        :consume t)
                                  (help :short-option "h"
                                        :long-option "help"))
  (:help-function #'help/task)
  (when help
    (help/task)
    (uiop:quit 0))

  (load-project)
  (clails/task:initialize-task-system)

  (cond
    ;; List tasks
    (list
     (if args
         (clails/cmd:task/list (first args))
         (clails/cmd:task/list)))

    ;; Task info
    (info
     (clails/cmd:task/info info))

    ;; Execute task
    (args
     (let* ((task-spec (first args))
            (bracket-pos (position #\[ task-spec))
            (task-name (if bracket-pos
                           (subseq task-spec 0 bracket-pos)
                           task-spec))
            (args-string (when bracket-pos
                          (subseq task-spec bracket-pos)))
            (task-args (when args-string
                        (let ((close-pos (position #\] args-string)))
                          (when close-pos
                            (let ((args-part (subseq args-string 1 close-pos)))
                              (uiop:split-string args-part :separator ",")))))))
       (apply #'clails/cmd:task/run task-name task-args)))

    ;; No arguments - show help
    (t
     (help/task)
     (uiop:quit 0))))


(defun main (&rest argv)
  ;; Check for help option or no arguments
  (when (or (null argv)
            (string= (first argv) "-h")
            (string= (first argv) "--help"))
    (help)
    (uiop:quit 0))

  ;; Check for command-specific help
  (when (and (>= (length argv) 2)
             (or (member "-h" argv :test #'string=)
                 (member "--help" argv :test #'string=)))
    (let* ((cmd-name (first argv))
           (cmd-config (find cmd-name (getf *config* :commands)
                            :key (lambda (cmd) (getf cmd :command))
                            :test #'string=)))
      (if (and cmd-config (getf cmd-config :help-function))
          (funcall (getf cmd-config :help-function))
          (help))
      (uiop:quit 0)))

  (let ((c (getcmd:getcmd argv *config* #'help)))
    (apply (getf c :function)
           (getf c :args))))

;;; vim: set ft=lisp lisp:
